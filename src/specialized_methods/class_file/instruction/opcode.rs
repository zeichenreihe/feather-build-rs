use anyhow::{bail, Result};
use crate::specialized_methods::class_file::instruction::CodeReader;
use crate::specialized_methods::class_file::MyRead;

#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) enum ArrayType {
	Nope
}

impl ArrayType {
	fn parse(_: u8) -> Result<ArrayType> {
		// TODO: implement this!
		Ok(ArrayType::Nope)
	}
}

//#[warn(missing_docs)]

#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) enum Opcode {
	AALoad,
	AAStore,
	AConstNull,
	ALoad(usize),
	ANewArray(usize),
	AReturn,
	ArrayLength,
	AStore(usize),
	AThrow,
	BALoad,
	BAStore,
	BIPush(u8),
	Breakpoint,
	CALoad,
	CAStore,
	CheckCast(usize),
	D2f,
	D2i,
	D2l,
	DAdd,
	DALoad,
	DAStore,
	DCmpG,
	DCmpL,
	DConst0,
	DConst1,
	DDiv,
	DLoad(usize),
	DMul,
	DNeg,
	DRem,
	DReturn,
	DStore(usize),
	DSub,
	Dup,
	DupX1,
	DupX2,
	Dup2,
	Dup2X1,
	Dup2X2,
	F2d,
	F2i,
	F2l,
	FAdd,
	FALoad,
	FAStore,
	FCmpG,
	FCmpL,
	FConst0,
	FConst1,
	FConst2,
	FDiv,
	FLoad(usize),
	FMul,
	FNeg,
	FRem,
	FReturn,
	FStore(usize),
	FSub,
	GetField(usize),
	GetStatic(usize),
	Goto(i16),
	GotoW(i32),
	I2b,
	I2c,
	I2d,
	I2f,
	I2l,
	I2s,
	IAdd,
	IALoad,
	IAnd,
	IAStore,
	IConstM1, IConst0, IConst1, IConst2, IConst3, IConst4, IConst5,
	IDiv,
	IfACmpEq(i16),
	IfACmpNe(i16),
	IfICmpEq(i16),
	IfICmpGe(i16),
	IfICmpGt(i16),
	IfICmpLe(i16),
	IfICmpLt(i16),
	IfICmpNe(i16),
	IfEq(i16),
	IfGe(i16),
	IfGt(i16),
	IfLe(i16),
	IfLt(i16),
	IfNe(i16),
	IfNonNull(i16),
	IfNull(i16),
	IInc { lv_index: usize, const_: i32 },
	ILoad(usize),
	ImpDep1, ImpDep2,
	IMul,
	INeg,
	InstanceOf(usize),
	InvokeDynamic { call_site: usize, zero1: u8, zero2: u8 },
	InvokeInterface { method_ref: usize, count: u8, zero: u8 },
	InvokeSpecial(usize),
	InvokeStatic(usize),
	InvokeVirtual(usize),
	IOr,
	IRem,
	IReturn,
	IShl,
	IShr,
	IStore(usize),
	ISub,
	IUShr,
	IXor,
	Jsr(i16),
	JsrW(i32),
	L2d,
	L2f,
	L2i,
	LAdd,
	LALoad,
	LAnd,
	LAStore,
	LCmp,
	LConst0, LConst1,
	Ldc(usize),
	LDiv,
	LLoad(usize),
	LMul,
	LNeg,
	LookupSwitch {
		default_target: i32,
		npairs: usize,
		targets: Vec<(i32, i32)>, // [npairs]
	},
	LOr,
	LRem,
	LReturn,
	LShl,
	LShr,
	LStore(usize),
	LSub,
	LUShr,
	LXor,
	MonitorEnter,
	MonitorExit,
	MultiANewArray(usize, usize),
	New(usize),
	NewArray { a_type: u8 },
	Nop,
	Pop,
	Pop2,
	PutField(usize),
	PutStatic(usize),
	Ret(usize),
	Return,
	SALoad,
	SAStore,
	SIPush(i16),
	Swap,
	TableSwitch {
		default_target: i32,
		low: i32,
		high: i32,
		targets: Vec<i32>, // [high - low + 1]
	}
}

impl Opcode {
	pub(crate) fn parse(reader: &mut impl CodeReader) -> Result<()> {
		match reader.read_u8()? {
			0x32 => Opcode::AALoad,
			0x53 => Opcode::AAStore,
			0x01 => Opcode::AConstNull,
			0x19 => Opcode::ALoad(reader.read_u8_as_usize()?),
			0x2a => Opcode::ALoad(0),
			0x2b => Opcode::ALoad(1),
			0x2c => Opcode::ALoad(2),
			0x2d => Opcode::ALoad(3),
			0xbd => Opcode::ANewArray(reader.read_u16_as_usize()?),
			0xb0 => Opcode::AReturn,
			0xbe => Opcode::ArrayLength,
			0x3a => Opcode::AStore(reader.read_u8_as_usize()?),
			0x4b => Opcode::AStore(0),
			0x4c => Opcode::AStore(1),
			0x4d => Opcode::AStore(2),
			0x4e => Opcode::AStore(3),
			0xbf => Opcode::AThrow,
			0x33 => Opcode::BALoad,
			0x54 => Opcode::BAStore,
			0x10 => Opcode::BIPush(reader.read_u8()?),
			0xca => Opcode::Breakpoint,
			0x34 => Opcode::CALoad,
			0x55 => Opcode::CAStore,
			0xc0 => Opcode::CheckCast(reader.read_u16_as_usize()?),
			0x90 => Opcode::D2f,
			0x8e => Opcode::D2i,
			0x8f => Opcode::D2l,
			0x63 => Opcode::DAdd,
			0x31 => Opcode::DALoad,
			0x52 => Opcode::DAStore,
			0x98 => Opcode::DCmpG,
			0x97 => Opcode::DCmpL,
			0x0e => Opcode::DConst0,
			0x0f => Opcode::DConst1,
			0x6f => Opcode::DDiv,
			0x18 => Opcode::DLoad(reader.read_u8_as_usize()?),
			0x26 => Opcode::DLoad(0),
			0x27 => Opcode::DLoad(1),
			0x28 => Opcode::DLoad(2),
			0x29 => Opcode::DLoad(3),
			0x6b => Opcode::DMul,
			0x77 => Opcode::DNeg,
			0x73 => Opcode::DRem,
			0xaf => Opcode::DReturn,
			0x39 => Opcode::DStore(reader.read_u8_as_usize()?),
			0x47 => Opcode::DStore(0),
			0x48 => Opcode::DStore(1),
			0x49 => Opcode::DStore(2),
			0x4a => Opcode::DStore(3),
			0x67 => Opcode::DSub,
			0x59 => Opcode::Dup,
			0x5a => Opcode::DupX1,
			0x5b => Opcode::DupX2,
			0x5c => Opcode::Dup2,
			0x5d => Opcode::Dup2X1,
			0x5e => Opcode::Dup2X2,
			0x8d => Opcode::F2d,
			0x8b => Opcode::F2i,
			0x8c => Opcode::F2l,
			0x62 => Opcode::FAdd,
			0x30 => Opcode::FALoad,
			0x51 => Opcode::FAStore,
			0x96 => Opcode::FCmpG,
			0x95 => Opcode::FCmpL,
			0x0b => Opcode::FConst0,
			0x0c => Opcode::FConst1,
			0x0d => Opcode::FConst2,
			0x6e => Opcode::FDiv,
			0x17 => Opcode::FLoad(reader.read_u8_as_usize()?),
			0x22 => Opcode::FLoad(0),
			0x23 => Opcode::FLoad(1),
			0x24 => Opcode::FLoad(2),
			0x25 => Opcode::FLoad(3),
			0x6a => Opcode::FMul,
			0x76 => Opcode::FNeg,
			0x72 => Opcode::FRem,
			0xae => Opcode::FReturn,
			0x38 => Opcode::FStore(reader.read_u8_as_usize()?),
			0x43 => Opcode::FStore(0),
			0x44 => Opcode::FStore(1),
			0x45 => Opcode::FStore(2),
			0x46 => Opcode::FStore(3),
			0x66 => Opcode::FSub,
			0xb4 => Opcode::GetField(reader.read_u16_as_usize()?),
			0xb2 => Opcode::GetStatic(reader.read_u16_as_usize()?),
			0xa7 => Opcode::Goto(reader.read_i16()?),
			0xc8 => Opcode::GotoW(reader.read_i32()?),
			0x91 => Opcode::I2b,
			0x92 => Opcode::I2c,
			0x87 => Opcode::I2d,
			0x86 => Opcode::I2f,
			0x85 => Opcode::I2l,
			0x93 => Opcode::I2s,
			0x60 => Opcode::IAdd,
			0x2e => Opcode::IALoad,
			0x7e => Opcode::IAnd,
			0x4f => Opcode::IAStore,
			0x02 => Opcode::IConstM1,
			0x03 => Opcode::IConst0,
			0x04 => Opcode::IConst1,
			0x05 => Opcode::IConst2,
			0x06 => Opcode::IConst3,
			0x07 => Opcode::IConst4,
			0x08 => Opcode::IConst5,
			0x6c => Opcode::IDiv,
			0xa5 => Opcode::IfACmpEq(reader.read_i16()?),
			0xa6 => Opcode::IfACmpNe(reader.read_i16()?),
			0x9f => Opcode::IfICmpEq(reader.read_i16()?),
			0xa2 => Opcode::IfICmpGe(reader.read_i16()?),
			0xa3 => Opcode::IfICmpGt(reader.read_i16()?),
			0xa4 => Opcode::IfICmpLe(reader.read_i16()?),
			0xa1 => Opcode::IfICmpLt(reader.read_i16()?),
			0xa0 => Opcode::IfICmpNe(reader.read_i16()?),
			0x99 => Opcode::IfEq(reader.read_i16()?),
			0x9c => Opcode::IfGe(reader.read_i16()?),
			0x9d => Opcode::IfGt(reader.read_i16()?),
			0x9e => Opcode::IfLe(reader.read_i16()?),
			0x9b => Opcode::IfLt(reader.read_i16()?),
			0x9a => Opcode::IfNe(reader.read_i16()?),
			0xc7 => Opcode::IfNonNull(reader.read_i16()?),
			0xc6 => Opcode::IfNull(reader.read_i16()?),
			0x84 => Opcode::IInc {
				lv_index: reader.read_u8_as_usize()?,
				const_: reader.read_u8()? as i32,
			},
			0x15 => Opcode::ILoad(reader.read_u8_as_usize()?),
			0x1a => Opcode::ILoad(0),
			0x1b => Opcode::ILoad(1),
			0x1c => Opcode::ILoad(2),
			0x1d => Opcode::ILoad(3),
			0xfe => Opcode::ImpDep1,
			0xff => Opcode::ImpDep2,
			0x68 => Opcode::IMul,
			0x74 => Opcode::INeg,
			0xc1 => Opcode::InstanceOf(reader.read_u16_as_usize()?),
			0xba => Opcode::InvokeDynamic {
				call_site: reader.read_u16_as_usize()?,
				zero1: reader.read_u8()?, // == 0
				zero2: reader.read_u8()?, // == 0
			},
			0xb9 => Opcode::InvokeInterface {
				method_ref: reader.read_u16_as_usize()?,
				count: reader.read_u8()?,
				zero: reader.read_u8()?, // == 0
			},
			0xb7 => Opcode::InvokeSpecial(reader.read_u16_as_usize()?),
			0xb8 => Opcode::InvokeStatic(reader.read_u16_as_usize()?),
			0xb6 => Opcode::InvokeVirtual(reader.read_u16_as_usize()?),
			0x80 => Opcode::IOr,
			0x70 => Opcode::IRem,
			0xac => Opcode::IReturn,
			0x78 => Opcode::IShl,
			0x7a => Opcode::IShr,
			0x36 => Opcode::IStore(reader.read_u8_as_usize()?),
			0x3b => Opcode::IStore(0),
			0x3c => Opcode::IStore(1),
			0x3d => Opcode::IStore(2),
			0x3e => Opcode::IStore(3),
			0x64 => Opcode::ISub,
			0x7c => Opcode::IUShr,
			0x82 => Opcode::IXor,
			0xa8 => Opcode::Jsr(reader.read_i16()?),
			0xc9 => Opcode::JsrW(reader.read_i32()?),
			0x8a => Opcode::L2d,
			0x89 => Opcode::L2f,
			0x88 => Opcode::L2i,
			0x61 => Opcode::LAdd,
			0x2f => Opcode::LALoad,
			0x7f => Opcode::LAnd,
			0x50 => Opcode::LAStore,
			0x94 => Opcode::LCmp,
			0x09 => Opcode::LConst0,
			0x0a => Opcode::LConst1,
			0x12 => Opcode::Ldc(reader.read_u8_as_usize()?),
			0x13 => Opcode::Ldc(reader.read_u16_as_usize()?),
			0x14 => Opcode::Ldc(reader.read_u16_as_usize()?),
			0x6d => Opcode::LDiv,
			0x16 => Opcode::LLoad(reader.read_u8_as_usize()?),
			0x1e => Opcode::LLoad(0),
			0x1f => Opcode::LLoad(1),
			0x20 => Opcode::LLoad(2),
			0x21 => Opcode::LLoad(3),
			0x69 => Opcode::LMul,
			0x75 => Opcode::LNeg,
			0xab => { // LookupSwitch
				reader.move_to_next_4_byte_boundary()?;

				let default_target = reader.read_i32()?;
				let npairs = reader.read_u32_as_usize()?;

				let mut targets = Vec::with_capacity(npairs);
				for _ in 0..npairs {
					let match_ = reader.read_i32()?;
					let branch_target = reader.read_i32()?;

					targets.push((match_, branch_target));
				}

				Opcode::LookupSwitch { default_target, npairs, targets }
			},
			0x81 => Opcode::LOr,
			0x71 => Opcode::LRem,
			0xad => Opcode::LReturn,
			0x79 => Opcode::LShl,
			0x7b => Opcode::LShr,
			0x37 => Opcode::LStore(reader.read_u8_as_usize()?),
			0x3f => Opcode::LStore(0),
			0x40 => Opcode::LStore(1),
			0x41 => Opcode::LStore(2),
			0x42 => Opcode::LStore(3),
			0x65 => Opcode::LSub,
			0x7d => Opcode::LUShr,
			0x83 => Opcode::LXor,
			0xc2 => Opcode::MonitorEnter,
			0xc3 => Opcode::MonitorExit,
			0xc5 => Opcode::MultiANewArray(
				reader.read_u16_as_usize()?,
				reader.read_u8_as_usize()? // >= 1
			),
			0xbb => Opcode::New(reader.read_u16_as_usize()?),
			0xbc => Opcode::NewArray {
				a_type: reader.read_u8()?,
			},
			0x00 => Opcode::Nop,
			0x57 => Opcode::Pop,
			0x58 => Opcode::Pop2,
			0xb5 => Opcode::PutField(reader.read_u16_as_usize()?),
			0xb3 => Opcode::PutStatic(reader.read_u16_as_usize()?),
			0xa9 => Opcode::Ret(reader.read_u8_as_usize()?),
			0xb1 => Opcode::Return,
			0x35 => Opcode::SALoad,
			0x56 => Opcode::SAStore,
			0x11 => Opcode::SIPush(reader.read_i16()?),
			0x5f => Opcode::Swap,
			0xaa => { // TableSwitch
				reader.move_to_next_4_byte_boundary()?;

				let default_target = reader.read_i32()?;
				let low = reader.read_i32()?;
				let high = reader.read_i32()?;

				let mut targets = Vec::new();
				for _ in low + 1 .. high {
					let branch_target = reader.read_i32()?;
					targets.push(branch_target);
				}

				Opcode::TableSwitch {
					default_target,
					low,
					high,
					targets,
				}
			},
			0xc4 => { // Wide
				match reader.read_u8()? {
					0x19 => Opcode::ALoad(reader.read_u16_as_usize()?),
					0x3a => Opcode::AStore(reader.read_u16_as_usize()?),
					0x18 => Opcode::DLoad(reader.read_u16_as_usize()?),
					0x39 => Opcode::DStore(reader.read_u16_as_usize()?),
					0x17 => Opcode::FLoad(reader.read_u16_as_usize()?),
					0x38 => Opcode::FStore(reader.read_u16_as_usize()?),
					0x15 => Opcode::ILoad(reader.read_u16_as_usize()?),
					0x36 => Opcode::IStore(reader.read_u16_as_usize()?),
					0x16 => Opcode::LLoad(reader.read_u16_as_usize()?),
					0x37 => Opcode::LStore(reader.read_u16_as_usize()?),
					0xa0 => Opcode::Ret(reader.read_u16_as_usize()?),
					0x84 => Opcode::IInc {
						lv_index: reader.read_u16_as_usize()?,
						const_: reader.read_i16()? as i32,
					},
					opcode => bail!("illegal wide opcode: {opcode:x}"),
				}
			},
			opcode => bail!("illegal opcode {opcode:x}"),
		};
		Ok(())
	}
}
